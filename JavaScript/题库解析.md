# JavaScript 面试题库解析

## 总共30道题，完整答案如下：

---

## 1. JavaScript 数据类型及区别

### 问题
JavaScript 数据类型有哪些？它们的区别是什么？

### 参考答案
**JavaScript 数据类型分为两大类：**

#### 原始数据类型（7种）
1. **String** - 字符串
2. **Number** - 数字
3. **Boolean** - 布尔值
4. **Undefined** - 未定义
5. **Null** - 空值
6. **Symbol** - 唯一标识符（ES6）
7. **BigInt** - 大整数（ES2020）

#### 引用数据类型（1种）
1. **Object** - 对象（包括Array、Function、Date、RegExp等）

#### 区别
| 特性 | 原始类型 | 引用类型 |
|------|----------|----------|
| 存储位置 | 栈内存 | 堆内存 |
| 访问方式 | 按值访问 | 按引用访问 |
| 复制方式 | 直接复制值 | 复制引用地址 |
| 比较方式 | 比较值 | 比较引用地址 |

---

## 2. 如何判断 JavaScript 数据类型？

### 参考答案

#### 最准确的方法
```javascript
function getType(value) {
  return Object.prototype.toString.call(value).slice(8, -1);
}

getType([]);           // 'Array'
getType({});           // 'Object'
getType(null);         // 'Null'
getType(undefined);    // 'Undefined'
```

---

## 3. 什么是作用域和作用域链？

### 参考答案

**作用域**：代码中变量、函数、对象的可访问性范围。

**作用域链**：查找变量的机制，从内向外逐层查找。

```javascript
var a = 1;

function outer() {
  var b = 2;
  
  function inner() {
    console.log(a, b); // 通过作用域链访问
  }
}
```

---

## 4. 解释 JavaScript 中的执行上下文

### 参考答案

**执行上下文**：JavaScript 代码执行时的环境，包含变量、函数、this等信息。

**三种执行上下文**：
1. **全局执行上下文** - 代码开始执行时创建
2. **函数执行上下文** - 每次调用函数时创建
3. **eval执行上下文** - eval函数内部

**执行上下文栈**：
```
全局上下文（栈底）
  ↓
函数上下文1
  ↓
函数上下文2（栈顶）
```

**执行上下文组成**：
```
ExecutionContext = {
  VariableObject: {},    // 变量对象
  ScopeChain: [],        // 作用域链
  ThisBinding: {}        // this指向
}
```

---

## 5. var、let、const 的区别是什么？

### 参考答案

| 特性 | var | let | const |
|------|-----|-----|-------|
| 作用域 | 函数作用域 | 块级作用域 | 块级作用域 |
| 变量提升 | 是 | 否 | 否 |
| 重复声明 | 允许 | 不允许 | 不允许 |
| 重新赋值 | 允许 | 允许 | 不允许 |
| 暂时性死区 | 无 | 有 | 有 |

**示例**：
```javascript
// var - 函数作用域
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100);
}
// 输出：3 3 3

// let - 块级作用域
for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 100);
}
// 输出：0 1 2

// const - 不可重新赋值
const pi = 3.14;
pi = 3.15; // 报错

// 但const对象的属性可以修改
const obj = { name: 'Tom' };
obj.name = 'Jerry'; // ✅
```

---

## 6. JavaScript 的原型链是什么？

### 参考答案

**原型链**：JavaScript 对象通过原型继承形成的一条链式结构。

**工作原理**：
```javascript
function Person(name) {
  this.name = name;
}

Person.prototype.sayHello = function() {
  console.log('Hello, ' + this.name);
};

const person = new Person('Tom');
person.sayHello();

// 原型链示例
console.log(person.__proto__ === Person.prototype); // true
console.log(person.__proto__.__proto__ === Object.prototype); // true
console.log(person.__proto__.__proto__.__proto__ === null); // true
```

**原型链查找**：
```
person对象
  ↓ __proto__
Person.prototype
  ↓ __proto__
Object.prototype
  ↓ __proto__
null（查找结束）
```

---

## 7. prototype 和 __proto__ 的区别

### 参考答案

| 特性 | prototype | __proto__ |
|------|-----------|-----------|
| 针对对象 | 构造函数 | 实例对象 |
| 用途 | 定义原型链 | 访问原型链 |
| 标准化 | ✅ | ❌（非标准）|

```javascript
function Person() {}
const person = new Person();

console.log(Person.prototype);  // 构造函数的原型对象
console.log(person.__proto__);  // 实例的原型指向
console.log(person.__proto__ === Person.prototype); // true
```

---

## 8. 如何实现继承？有哪些方法？

### 参考答案

#### 方法1：原型链继承
```javascript
function Parent() {
  this.name = 'parent';
}

function Child() {}
Child.prototype = new Parent();

const child = new Child();
console.log(child.name); // 'parent'
```

#### 方法2：构造函数继承
```javascript
function Parent(name) {
  this.name = name;
}

function Child(name) {
  Parent.call(this, name);
}

const child = new Child('child');
console.log(child.name); // 'child'
```

#### 方法3：组合继承
```javascript
function Parent(name) {
  this.name = name;
}

Parent.prototype.sayHello = function() {
  console.log('Hello, ' + this.name);
};

function Child(name) {
  Parent.call(this, name);
}

Child.prototype = new Parent();
Child.prototype.constructor = Child;

const child = new Child('Tom');
child.sayHello(); // 'Hello, Tom'
```

#### 方法4：ES6 Class继承
```javascript
class Parent {
  constructor(name) {
    this.name = name;
  }
  
  sayHello() {
    console.log('Hello, ' + this.name);
  }
}

class Child extends Parent {
  constructor(name, age) {
    super(name);
    this.age = age;
  }
}

const child = new Child('Tom', 18);
child.sayHello(); // 'Hello, Tom'
```

---

## 9. 什么是构造函数？new 操作符做了什么？

### 参考答案

**构造函数**：用于创建和初始化对象的函数，首字母通常大写。

**new 操作符做了4件事**：
1. 创建一个新对象
2. 将对象的原型指向构造函数的prototype
3. 将构造函数的this指向新对象
4. 返回新对象

**手动实现new**：
```javascript
function myNew(constructor, ...args) {
  // 1. 创建新对象
  const obj = {};
  
  // 2. 设置原型链
  obj.__proto__ = constructor.prototype;
  
  // 3. 绑定this并执行构造函数
  const result = constructor.apply(obj, args);
  
  // 4. 返回对象（如果构造函数返回对象则返回它）
  return result instanceof Object ? result : obj;
}

// 测试
function Person(name) {
  this.name = name;
}

const person = myNew(Person, 'Tom');
console.log(person.name); // 'Tom'
```

---

## 10. ES6 Class 和 ES5 构造函数的关系

### 参考答案

**ES6 Class 是 ES5 构造函数的语法糖**。

**本质相同**：
```javascript
// ES6 Class
class Person {
  constructor(name) {
    this.name = name;
  }
  
  sayHello() {
    console.log('Hello, ' + this.name);
  }
}

// 等价于ES5
function Person(name) {
  this.name = name;
}

Person.prototype.sayHello = function() {
  console.log('Hello, ' + this.name);
};
```

**主要区别**：
1. Class 必须使用 new 调用，构造函数可以普通调用
2. Class 的方法不可枚举，构造函数方法可枚举
3. Class 默认严格模式

---

## 11. JavaScript 的事件循环机制

### 参考答案

**事件循环（Event Loop）**：JavaScript 的执行机制，用于协调同步代码、异步任务和UI渲染。

**执行过程**：
1. 执行同步代码（调用栈）
2. 同步代码执行完，检查微任务队列
3. 清空所有微任务
4. 检查是否需要UI渲染
5. 执行一个宏任务
6. 重复步骤2-5

**示例**：
```javascript
console.log('1'); // 同步

setTimeout(() => console.log('2'), 0); // 宏任务

Promise.resolve().then(() => console.log('3')); // 微任务

console.log('4'); // 同步

// 输出顺序：1 → 4 → 3 → 2
```

---

## 12. 宏任务和微任务的区别

### 参考答案

**宏任务**：setTimeout、setInterval、setImmediate、I/O、UI渲染

**微任务**：Promise.then、MutationObserver、queueMicrotask

**执行顺序**：
```
同步代码
  ↓
微任务队列（全部执行）
  ↓
宏任务队列（执行一个）
  ↓
微任务队列
  ↓
重复...
```

**示例**：
```javascript
console.log('start');

setTimeout(() => console.log('timeout'), 0);

Promise.resolve().then(() => {
  console.log('promise1');
  Promise.resolve().then(() => console.log('promise2'));
});

Promise.resolve().then(() => console.log('promise3'));

console.log('end');

// 输出：start → end → promise1 → promise3 → promise2 → timeout
```

---

## 13. Promise 的基本用法和原理

### 参考答案

**基本用法**：
```javascript
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('成功');
  }, 1000);
});

promise.then(result => {
  console.log(result);
}).catch(error => {
  console.log(error);
});
```

**Promise状态**：
- **pending** - 等待中
- **fulfilled** - 已成功
- **rejected** - 已失败

**手写Promise**：
```javascript
class MyPromise {
  constructor(executor) {
    this.status = 'pending';
    this.value = undefined;
    this.reason = undefined;
    this.onResolvedCallbacks = [];
    this.onRejectedCallbacks = [];
    
    const resolve = (value) => {
      if (this.status === 'pending') {
        this.status = 'fulfilled';
        this.value = value;
        this.onResolvedCallbacks.forEach(fn => fn());
      }
    };
    
    const reject = (reason) => {
      if (this.status === 'pending') {
        this.status = 'rejected';
        this.reason = reason;
        this.onRejectedCallbacks.forEach(fn => fn());
      }
    };
    
    try {
      executor(resolve, reject);
    } catch (error) {
      reject(error);
    }
  }
  
  then(onFulfilled, onRejected) {
    return new MyPromise((resolve, reject) => {
      if (this.status === 'fulfilled') {
        setTimeout(() => {
          try {
            const x = onFulfilled(this.value);
            resolve(x);
          } catch (error) {
            reject(error);
          }
        }, 0);
      } else if (this.status === 'rejected') {
        setTimeout(() => {
          try {
            const x = onRejected(this.reason);
            resolve(x);
          } catch (error) {
            reject(error);
          }
        }, 0);
      } else {
        this.onResolvedCallbacks.push(() => {
          setTimeout(() => {
            try {
              const x = onFulfilled(this.value);
              resolve(x);
            } catch (error) {
              reject(error);
            }
          }, 0);
        });
        
        this.onRejectedCallbacks.push(() => {
          setTimeout(() => {
            try {
              const x = onRejected(this.reason);
              resolve(x);
            } catch (error) {
              reject(error);
            }
          }, 0);
        });
      }
    });
  }
}
```

---

## 14. async/await 的使用和原理

### 参考答案

**async/await**：Promise的语法糖，用于同步方式写异步代码。

**基本用法**：
```javascript
async function fetchData() {
  try {
    const data1 = await fetch('/api/data1');
    const data2 = await fetch('/api/data2');
    return [data1, data2];
  } catch (error) {
    console.error(error);
  }
}
```

**原理**：
```javascript
// async函数返回Promise
async function test() {
  return 1;
}
// 等价于
function test() {
  return Promise.resolve(1);
}

// await表达式暂停async函数执行
async function test() {
  const result = await Promise.resolve(1);
  return result;
}
// 等价于
function test() {
  return Promise.resolve(1).then(result => {
    return Promise.resolve(result);
  });
}
```

---

## 15. 如何处理多个异步操作的并行和串行？

### 参考答案

**并行执行**（Promise.all）：
```javascript
async function parallel() {
  const [data1, data2, data3] = await Promise.all([
    fetch('/api/data1'),
    fetch('/api/data2'),
    fetch('/api/data3')
  ]);
}
```

**串行执行**：
```javascript
async function serial() {
  const data1 = await fetch('/api/data1');
  const data2 = await fetch('/api/data2');
  const data3 = await fetch('/api/data3');
}
```

**部分失败继续执行**（Promise.allSettled）：
```javascript
async function allSettled() {
  const results = await Promise.allSettled([
    fetch('/api/data1'),
    fetch('/api/data2'),
    fetch('/api/data3')
  ]);
  
  results.forEach((result, index) => {
    if (result.status === 'fulfilled') {
      console.log(`请求${index}成功`, result.value);
    } else {
      console.log(`请求${index}失败`, result.reason);
    }
  });
}
```

---

## 16. 什么是闭包？有什么应用场景？

### 参考答案

**闭包**：函数能记住它定义时的作用域，即使在该函数在外部执行。

**示例**：
```javascript
function createCounter() {
  let count = 0;
  
  return function() {
    return ++count;
  };
}

const counter = createCounter();
console.log(counter()); // 1
console.log(counter()); // 2
```

**应用场景**：
1. **数据私有化**
```javascript
function createModule() {
  let privateData = [];
  
  return {
    add(item) { privateData.push(item); },
    get() { return [...privateData]; }
  };
}
```

2. **函数柯里化**
```javascript
function curry(fn) {
  return function curried(...args) {
    if (args.length >= fn.length) {
      return fn(...args);
    }
    return (...more) => curried(...args, ...more);
  };
}
```

3. **事件处理**
```javascript
for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 1000);
}
```

---

## 17. JavaScript 中 this 的指向规则

### 参考答案

**this的4种绑定规则**：

1. **默认绑定**
```javascript
function fn() {
  console.log(this); // window（严格模式为undefined）
}
fn();
```

2. **隐式绑定**
```javascript
const obj = {
  name: 'Tom',
  sayName() {
    console.log(this.name); // 'Tom'
  }
};
obj.sayName();
```

3. **显式绑定**
```javascript
function sayName() {
  console.log(this.name);
}

const obj = { name: 'Tom' };
sayName.call(obj);  // 'Tom'
sayName.apply(obj); // 'Tom'
sayName.bind(obj)(); // 'Tom'
```

4. **new绑定**
```javascript
function Person(name) {
  this.name = name;
}

const person = new Person('Tom');
console.log(person.name); // 'Tom'
```

**箭头函数的this**：继承外层作用域的this。

---

## 18. call、apply、bind 的区别

### 参考答案

| 方法 | 参数格式 | 是否立即执行 | 返回值 |
|------|----------|--------------|--------|
| call | 参数列表 | ✅ | 函数执行结果 |
| apply | 参数数组 | ✅ | 函数执行结果 |
| bind | 参数列表 | ❌ | 新函数 |

**示例**：
```javascript
function add(a, b) {
  return this.value + a + b;
}

const obj = { value: 10 };

console.log(add.call(obj, 1, 2));      // 13
console.log(add.apply(obj, [1, 2]));   // 13
console.log(add.bind(obj, 1, 2)());   // 13
```

**手写实现**：
```javascript
// call
Function.prototype.myCall = function(context, ...args) {
  context = context || window;
  const fn = Symbol();
  context[fn] = this;
  const result = context[fn](...args);
  delete context[fn];
  return result;
};

// apply
Function.prototype.myApply = function(context, args) {
  context = context || window;
  const fn = Symbol();
  context[fn] = this;
  const result = context[fn](...(args || []));
  delete context[fn];
  return result;
};

// bind
Function.prototype.myBind = function(context, ...args) {
  return (...newArgs) => {
    return this.call(context, ...args, ...newArgs);
  };
};
```

---

## 19. 箭头函数和普通函数的区别

### 参考答案

| 特性 | 普通函数 | 箭头函数 |
|------|----------|----------|
| this绑定 | 动态绑定 | 继承外层this |
| arguments对象 | 有 | 无 |
| 构造函数 | 可作构造函数 | 不可作构造函数 |
| 原型对象 | 有prototype | 无prototype |
| super | 支持 | 支持 |
| new调用 | 可 | 不可 |

**示例**：
```javascript
// this的区别
const obj = {
  name: 'Tom',
  
  normal() {
    setTimeout(function() {
      console.log(this.name); // undefined
    }, 1000);
  },
  
  arrow() {
    setTimeout(() => {
      console.log(this.name); // 'Tom'
    }, 1000);
  }
};
```

---

## 20. 函数柯里化是什么？如何实现？

### 参考答案

**函数柯里化**：将多参数函数转换为单参数函数的序列。

**示例**：
```javascript
// 普通函数
function add(a, b, c) {
  return a + b + c;
}

// 柯里化后
const curriedAdd = curry(add);
console.log(curriedAdd(1)(2)(3)); // 6
```

**实现**：
```javascript
function curry(fn) {
  return function curried(...args) {
    if (args.length >= fn.length) {
      return fn(...args);
    }
    return (...more) => curried(...args, ...more);
  };
}

// 或者使用ES6
const curry = fn => curried => (...args) => 
  args.length >= fn.length 
    ? fn(...args) 
    : (...more) => curried(...args, ...more);
```

---

## 21. 解构赋值的用法

### 参考答案

**数组解构**：
```javascript
const [a, b, c] = [1, 2, 3];
const [first, ...rest] = [1, 2, 3, 4];
const [, , third] = [1, 2, 3];
```

**对象解构**：
```javascript
const { name, age } = { name: 'Tom', age: 18 };
const { name: userName, age: userAge } = { name: 'Tom', age: 18 };
const { name = 'Anonymous' } = { };
```

**嵌套解构**：
```javascript
const { user: { name, age } } = { 
  user: { name: 'Tom', age: 18 } 
};
```

**函数参数解构**：
```javascript
function greet({ name = 'Guest', message = 'Hello' }) {
  console.log(`${message}, ${name}`);
}

greet({ name: 'Tom' }); // 'Hello, Tom'
```

---

## 22. 模板字符串的优势

### 参考答案

**传统字符串拼接**：
```javascript
const name = 'Tom';
const age = 18;
const message = 'Hello, ' + name + '. You are ' + age + ' years old.';
```

**模板字符串**：
```javascript
const name = 'Tom';
const age = 18;
const message = `Hello, ${name}. You are ${age} years old.`;
```

**优势**：
1. 更简洁易读
2. 支持多行字符串
3. 支持表达式
4. 支持标签函数

**多行字符串**：
```javascript
const html = `
  <div>
    <p>Hello, ${name}</p>
  </div>
`;
```

---

## 23. 扩展运算符的应用场景

### 参考答案

**数组操作**：
```javascript
// 合并数组
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
const merged = [...arr1, ...arr2];

// 复制数组
const copy = [...arr1];

// 数组转函数参数
function sum(a, b, c) {
  return a + b + c;
}
const args = [1, 2, 3];
console.log(sum(...args)); // 6
```

**对象操作**：
```javascript
// 合并对象
const obj1 = { name: 'Tom' };
const obj2 = { age: 18 };
const merged = { ...obj1, ...obj2 };

// 复制对象
const copy = { ...obj1 };
```

---

## 24. Symbol 的用途

### 参考答案

**Symbol**：创建唯一的标识符，用于对象属性名。

**用途1：对象私有属性**
```javascript
const privateKey = Symbol();

const obj = {
  [privateKey]: 'private value',
  public: 'public value'
};

console.log(obj.public); // 'public value'
console.log(obj[privateKey]); // 'private value'
```

**用途2：避免属性名冲突**
```javascript
const sym1 = Symbol('description');
const sym2 = Symbol('description');

console.log(sym1 === sym2); // false

const obj = {
  [sym1]: 'value1',
  [sym2]: 'value2'
};
```

**用途3：内置Symbol**
```javascript
class MyClass {
  [Symbol.iterator]() {
    return { /* ... */ };
  }
}
```

---

## 25. Map 和 Set 与 Object、Array 的区别

### 参考答案

**Map vs Object**：
| 特性 | Map | Object |
|------|-----|--------|
| 键类型 | 任意类型 | 字符串或Symbol |
| 顺序 | 保持插入顺序 | 不保证 |
| 性能方法 | size、has、delete | 无 |
| 迭代 | 可迭代 | 不可迭代 |

```javascript
const map = new Map();
map.set('key1', 'value1');
map.set(1, 'value2');
console.log(map.size); // 2
```

**Set vs Array**：
| 特性 | Set | Array |
|------|-----|-------|
| 唯一性 | 自动去重 | 可能重复 |
| 性能 | 查找快O(1) | 查找慢O(n) |
| 方法 | has、add、delete | push、includes |

```javascript
const set = new Set([1, 2, 2, 3]);
console.log([...set]); // [1, 2, 3]
```

---

## 26. 手写 call/apply/bind

### 参考答案

```javascript
// call
Function.prototype.myCall = function(context, ...args) {
  context = context || window;
  const fn = Symbol();
  context[fn] = this;
  const result = context[fn](...args);
  delete context[fn];
  return result;
};

// apply
Function.prototype.myApply = function(context, args) {
  context = context || window;
  const fn = Symbol();
  context[fn] = this;
  const result = context[fn](...(args || []));
  delete context[fn];
  return result;
};

// bind
Function.prototype.myBind = function(context, ...args) {
  return (...newArgs) => {
    return this.call(context, ...args, ...newArgs);
  };
};
```

---

## 27. 手写 Promise

### 参考答案

```javascript
class MyPromise {
  constructor(executor) {
    this.status = 'pending';
    this.value = undefined;
    this.reason = undefined;
    this.onResolvedCallbacks = [];
    this.onRejectedCallbacks = [];
    
    const resolve = (value) => {
      if (this.status === 'pending') {
        this.status = 'fulfilled';
        this.value = value;
        this.onResolvedCallbacks.forEach(fn => fn());
      }
    };
    
    const reject = (reason) => {
      if (this.status === 'pending') {
        this.status = 'rejected';
        this.reason = reason;
        this.onRejectedCallbacks.forEach(fn => fn());
      }
    };
    
    try {
      executor(resolve, reject);
    } catch (error) {
      reject(error);
    }
  }
  
  then(onFulfilled, onRejected) {
    return new MyPromise((resolve, reject) => {
      if (this.status === 'fulfilled') {
        setTimeout(() => {
          try {
            const x = onFulfilled(this.value);
            resolve(x);
          } catch (error) {
            reject(error);
          }
        }, 0);
      } else if (this.status === 'rejected') {
        setTimeout(() => {
          try {
            const x = onRejected(this.reason);
            resolve(x);
          } catch (error) {
            reject(error);
          }
        }, 0);
      } else {
        this.onResolvedCallbacks.push(() => {
          setTimeout(() => {
            try {
              const x = onFulfilled(this.value);
              resolve(x);
            } catch (error) {
              reject(error);
            }
          }, 0);
        });
        
        this.onRejectedCallbacks.push(() => {
          setTimeout(() => {
            try {
              const x = onRejected(this.reason);
              resolve(x);
            } catch (error) {
              reject(error);
            }
          }, 0);
        });
      }
    });
  }
}
```

---

## 28. 手写防抖和节流函数

### 参考答案

**防抖**：
```javascript
function debounce(fn, delay) {
  let timer = null;
  
  return function(...args) {
    clearTimeout(timer);
    timer = setTimeout(() => {
      fn.apply(this, args);
    }, delay);
  };
}
```

**节流**：
```javascript
function throttle(fn, delay) {
  let timer = null;
  
  return function(...args) {
    if (!timer) {
      timer = setTimeout(() => {
        fn.apply(this, args);
        timer = null;
      }, delay);
    }
  };
}
```

---

## 29. 手写深拷贝

### 参考答案

```javascript
function deepClone(obj, hash = new WeakMap()) {
  if (obj === null || typeof obj !== 'object') {
    return obj;
  }
  
  if (hash.has(obj)) {
    return hash.get(obj);
  }
  
  const clone = Array.isArray(obj) ? [] : {};
  hash.set(obj, clone);
  
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      clone[key] = deepClone(obj[key], hash);
    }
  }
  
  return clone;
}
```

---

## 30. 手写数组扁平化

### 参考答案

**方法1：递归**
```javascript
function flatten(arr) {
  const result = [];
  
  for (const item of arr) {
    if (Array.isArray(item)) {
      result.push(...flatten(item));
    } else {
      result.push(item);
    }
  }
  
  return result;
}
```

**方法2：reduce**
```javascript
function flatten(arr) {
  return arr.reduce((acc, item) => {
    return acc.concat(Array.isArray(item) ? flatten(item) : item);
  }, []);
}
```

**方法3：ES6 flat**
```javascript
const arr = [1, [2, [3, 4]]];
console.log(arr.flat(Infinity)); // [1, 2, 3, 4]
```

---

**✅ 全部30道题的答案已整理完成！**