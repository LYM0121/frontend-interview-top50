# 字节跳动前端面试题集合

本目录整理了来自多个来源的字节跳动前端面试真题，包含前端开发、React、Vue、算法等多个方向的高频面试题。

## 📚 题目来源
- 掘金：记录一次字节前端面试（2025.2.13）
- 牛客网：字节Coze前端三面面经
- 掘金：字节前端三面复盘：基础不花哨，代码要扎实

---

## 🎯 面目分类

### 1. 网络安全与HTTP协议

#### 题目1：HTTP和HTTPS的区别
**问题**：HTTP和HTTPS协议的主要区别是什么？

**参考答案：**
1. **HTTPS协议需要CA证书，费用较高；而HTTP协议不需要**
2. **HTTP协议是超文本传输协议，信息是明文传输的；HTTPS则是具有安全性的SSL加密传输协议**
3. **使用不同的连接方式，端口也不同，HTTP协议端口是80，HTTPS协议端口是443**
4. **HTTP协议连接很简单，是无状态的；HTTPS协议是有SSL和HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP更加安全**

#### 题目2：HTTPS加密后会被攻击吗？
**问题**：HTTPS加密后会不会被攻击？有了解过吗？

**参考答案：**
HTTPS并不是完全安全的，仍可能受到以下攻击：
1. **中间人攻击**：非对称加密会被中间人攻击
2. **SSL/TLS漏洞**：Heartbleed等漏洞
3. **证书伪造**：如果CA被攻破，可能发行假证书
4. **降级攻击**：强制使用不安全的加密版本

#### 题目3：数字证书详解
**问题**：你说到了数字证书，可以详细说说吗？

**参考答案：**
数字证书是HTTPS通信中的关键组件，用于：
1. **身份验证**：确认网站的真实身份
2. **加密通信**：包含公钥用于加密
3. **防止中间人攻击**：通过CA签名确保证书可信

**数字证书包含的内容：**
- 证书版本号
- 序列号
- 签名（发行机构CA）
- 有效期
- 公钥信息
- 发行机构签名

---

### 2. 浏览器渲染

#### 题目4：浏览器渲染流程
**问题**：可以说说浏览器渲染相关的吗？

**参考答案：**
浏览器从输入URL到页面展示的完整渲染流程：

1. **解析HTML**：通过HTML文件得到DOM树
2. **解析CSS**：解析CSS得到CSS规则树
3. **构建渲染树**：DOM树 + CSS规则树 = 渲染树
4. **布局**：计算元素位置和大小（重排）
5. **绘制**：绘制元素到屏幕（重绘）

#### 题目5：渲染树详解
**问题**：你提到了渲染树，你能不能详细说说渲染树？

**参考答案：**
渲染树（Render Tree）是DOM树和CSSOM树的结合产物：
- **不可见元素不包含**：如`<script>`、`<style>`、`<meta>`等
- **每个节点包含样式**：继承和计算后的样式信息
- **构建过程**：从DOM树的根节点开始，递归构建
- **用途**：用于后续的布局和绘制

---

### 3. JavaScript基础

#### 题目6：手写防抖函数
**问题**：手写一个防抖函数

**参考答案：**
```javascript
function debounce(fn, delay) {
  let timer = null;
  return function(...args) {
    if (timer) clearTimeout(timer); // 注意：应该是clearTimeout
    timer = setTimeout(() => fn(...args), delay);
  }
}

// 正确版本
function debounce(fn, delay) {
  let timer = null;
  return function(...args) {
    if (timer) clearTimeout(timer);
    timer = setTimeout(() => fn.apply(this, args), delay);
  }
}
```

#### 题目7：手写节流函数
**问题**：手写一个节流函数

**参考答案：**
```javascript
function throttle(fn, delay) {
  let timer = null;
  return function(...args) {
    if (!timer) {
      timer = setTimeout(() => {
        fn.apply(this, args);
        timer = null;
      }, delay);
    }
  }
}
```

#### 题目8：实现EventEmitter
**问题**：简单实现一个EventEmitter

**参考答案：**
```javascript
class EventEmitter {
  constructor() {
    this.events = {}; // key: callback[] 的形式
  }

  // 订阅事件
  on(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = [];
    }
    this.events[eventName].push(callback);
  }

  // 发布事件
  emit(eventName, ...args) {
    const callbacks = this.events[eventName] || [];
    callbacks.forEach(callback => callback(...args));
  }

  // 移除监听
  off(eventName, callback) {
    const callbacks = this.events[eventName] || [];
    const index = callbacks.indexOf(callback);
    if (index > -1) {
      callbacks.splice(index, 1);
    }
  }

  // 只监听一次
  once(eventName, callback) {
    const onceCallback = (...args) => {
      callback(...args);
      this.off(eventName, onceCallback);
    };
    this.on(eventName, onceCallback);
  }
}
```

#### 题目9：实现Promise.all
**问题**：实现Promise.all

**参考答案：**
```javascript
function myPromiseAll(iterable) {
  return new Promise((resolve, reject) => {
    const arr = Array.from(iterable);
    const res = new Array(arr.length);
    let done = 0;
    
    if (arr.length === 0) return resolve([]);
    
    arr.forEach((p, i) => {
      Promise.resolve(p).then(
        value => {
          res[i] = value;
          if (++done === arr.length) resolve(res);
        },
        err => reject(err)
      );
    });
  });
}
```

---

### 4. React相关

#### 题目10：React Diff算法
**问题**：React Diff怎么做？

**参考答案：**
React的Diff算法核心思想：
1. **同层比较**：只会比较同一层级的节点，不会跨层级
2. **Key的作用**：通过key标识节点，提高diff效率，避免不必要的复用
3. **三种操作**：
   - Insert：插入新节点
   - Remove：删除节点
   - Update：更新节点属性

**Diff策略：**
- **Tree Diff**：递归对比DOM树
- **Component Diff**：对比组件类型
- **Element Diff**：对比元素类型和属性

#### 题目11：Fiber架构理解
**问题**：说说你对Fiber的理解

**参考答案：**
Fiber是React 16引入的新的协调机制：
1. **任务可中断**：将渲染工作分解为小单元，可被中断和恢复
2. **优先级调度**：高优先级任务先执行，低优先级任务延后
3. **时间切片**：每个时间片最多执行5ms，超时则交出控制权
4. **双缓存树**：currentFiber（当前显示）和workInProgressFiber（工作中）

**解决的问题：**
- 防止长任务阻塞主线程
- 支持任务优先级调度
- 实现并发模式

#### 题目12：React性能优化
**问题**：React做了哪些性能优化？

**参考答案：**
1. **memo**：避免不必要的组件重新渲染
2. **useMemo**：缓存计算结果，避免重复计算
3. **useCallback**：缓存函数引用，避免子组件不必要的更新
4. **shouldComponentUpdate**：手动控制组件是否更新
5. **React.lazy和Suspense**：代码分割和懒加载
6. **虚拟DOM和Diff算法**：最小化DOM操作

#### 题目13：useEffect执行时机
**问题**：useEffect什么时候执行？

**参考答案：**
useEffect在**浏览器完成渲染和绘制之后**执行，即：
- commit阶段完成
- DOM更新完毕
- 界面已经渲染到屏幕上

#### 题目14：useLayoutEffect与useEffect的区别
**问题**：useLayoutEffect用过没？和useEffect的区别

**参考答案：**
**useLayoutEffect**：
- 在**所有DOM更新之后，浏览器绘制之前**执行
- 可能会阻塞浏览器绘制

**useEffect**：
- 在**浏览器绘制之后**执行
- 不会阻塞绘制

**使用场景**：
- useLayoutEffect：需要读取DOM布局和样式时
- useEffect：大多数副作用使用useEffect

---

### 5. CSS基础

#### 题目15：visibility:hidden与display:none的区别
**问题**：visibility:hidden和display:none的区别

**参考答案：**
| 特性 | visibility:hidden | display:none |
|------|------------------|--------------|
| 占据空间 | 是 | 否 |
| 子元素影响 | 子元素也隐藏，但空间保留 | 子元素完全消失 |
| 重绘重排 | 只重绘 | 触发重排和重绘 |
| 绑承 | 可继承 | 不可继承 |
| 过渡效果 | 支持 | 不支持 |

---

### 6. 实际场景题

#### 题目16：搜索框请求处理
**问题**：有一个场景，发送多次请求，怎么保证参数与请求对应？

**参考答案：**
**场景**：一个输入框，不小心发了两次请求，怎么保证请求和对应的参数一致

**解决方案：**

**方法1：取消之前的请求**
```javascript
import axios from 'axios';

const CancelToken = axios.CancelToken;
let cancel;

function search(keyword) {
  if (cancel) {
    cancel('取消之前的请求');
  }
  
  cancel = new CancelToken(c => cancel = c);
  
  return axios.get('/api/search', {
    params: { q: keyword },
    cancelToken: cancel
  });
}
```

**方法2：请求序号校验**
```javascript
let requestId = 0;
const currentRequestId = {};

function search(keyword) {
  const currentId = ++requestId;
  
  return axios.get('/api/search', { params: { q: keyword } })
    .then(res => {
      if (currentIdra === requestId) {
        currentRequestId.value = res.data;
      }
    });
}
```

---

### 7. Vue相关

#### 题目17：Vue.nextTick原理
**问题**：Vue.nextTick的实现原理（Vue2/3通吃的本质）

**参考答案：**
**本质**：把回调压进微任务队列，等本轮DOM变更"flush"后再执行，保证你拿到的是真实更新后的DOM。

**关键点：**
1. **微任务优先级高于宏任务**：`Promise.then` > `setTimeout`
2. **Vue2实现**：用 `Promise` / `MutationObserver` / `setImmediate` / `setTimeout` 多重降级
3. **Vue3实现**：统一调度器（scheduler），`nextTick`实际是 `Promise.resolve().then(flushJobs)`

**简化实现：**
```javascript
const callbacks = [];
let pending = false;

function flushCallbacks() {
  pending = false;
  const copies = callbacks.slice();
  callbacks.length = 0;
  for (const cb of copies) cb();
}

export function nextTick(cb) {
  callbacks.push(cb);
  if (!pending) {
    pending = true;
    Promise.resolve().then(flushCallbacks);
  }
}
```

---

### 8. JavaScript事件循环

#### 题目18：EventLoop
**问题**：JavaScript的事件循环机制

**参考答案：**
JavaScript事件循环包含：
1. **调用栈**：执行同步代码
2. **任务队列**：
   - **宏任务队列**：setTimeout、setInterval、UI渲染等
   - **微任务队列**：Promise.then、MutationObserver等
3. **执行顺序**：
   - 同步代码 → 微任务队列 → 宏任务队列

**完整流程：**
```
1. 执行同步代码
2. 检查微任务队列，清空微任务
3. 执行UI渲染（如果需要）
4. 检查宏任务队列，执行一个宏任务
5. 重复步骤2-4
```

#### 题目19：微任务和宏任务
**问题**：微任务宏任务你知道哪些？

**参考答案：**
**微任务：**
- Promise.then / Promise.catch / Promise.finally
- MutationObserver
- queueMicrotask
- process.nextTick (Node.js环境)

**宏任务：**
- setTimeout
- setInterval
- setImmediate (Node.js环境)
- I/O操作
- UI渲染

---

### 9. 高频编程题

#### 题目20：岛屿数量（DFS/BFS/并查集）
**问题**：给定一个由 '1'（陆地）和 '0'（水）组成的的二维网格，计算网格中岛屿的数量。

**参考答案：**
```typescript
function numIslands(grid: string[][]): number {
  if (!grid.length) return 0;
  
  const m = grid.length, n = grid[0].length;
  let count = 0;
  const dirs = [[1,0], [-1,0], [0,1], [0,-1]];
  
  const dfs = (i: number, j: number) => {
    if (i < 0 || j < 0 || i >= m || j >= n || grid[i][j] !== '1') return;
    grid[i][j] = '0'; // 标记已访问
    for (const [dx, dy] of dirs) {
      dfs(i + dx, j + dy);
    }
  };
  
  for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
      if (grid[i][j] === '1') {
        count++;
        dfs(i, j);
      }
    }
  }
  
  return count;
}
```

#### 题目21：拼手气红包算法
**问题**：实现一个拼手气红包算法，总金额totalCents分，人数n人，每人至少1分

**参考答案：**
```typescript
function splitLucky(totalCents: number, n: number): number[] {
  if (n <= 0 || totalCents < n) throw new Error('非法参数');
  
  const res: number[] = [];
  let remain = totalCents, remainN = n;
  
  for (let i = 0; i < n - 1; i++) {
    // 每次在 [1, 2*平均-1] 间随机
    const max = Math.floor((remain / remainN) * 2) - 1;
    const cur = Math.max(1, Math.floor(Math.random() * max) + 1);
    res.push(cur);
    remain -= cur;
    remainN--;
  }
  
  res.push(remain); // 最后一个兜底
  return res;
}
```

---

## 📚 学习建议

### 重点掌握
1. **网络基础**：HTTP/HTTPS、缓存、跨域等
2. **浏览器原理**：渲染流程、事件循环、性能优化
3. **JavaScript基础**：闭包、原型链、事件机制
4. **React/Vue原理**：虚拟DOM、Diff算法、响应式原理
5. **算法能力**：高频算法题要能手写

### 刷题策略
1. **先基础后原理**：先掌握基础概念，再深入原理
2. **手写代码**：常见函数要能手写
3. **理解而非背诵**：理解原理比死记答案更重要
4. **总结归纳**：形成自己的知识体系

---

**最后更新**：2026年2月8日  
**题目来源**：掘金、牛客网、CSDN等平台真实面试题  
**整理者**：AI助手